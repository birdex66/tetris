#include "setup.hpp"

atomic<int> curBlock[4][10];
atomic<bool> run(true);
mutex grid_mutex;
static int stp;
static int indL;
static int indR;

void initNcurses(){
    initscr();
    cbreak();
    noecho();
    keypad(stdscr,TRUE);
    curs_set(0);
}

void initalizePattern(int patternIndex){
    if(patternIndex == 0) stp = 21;
    else stp = 20;

    indL = 100;
    indR = -100;

    for(int i=0; i<4; ++i){
        for(int j=0; j<10; ++j){
            int fer = (*allBlocks[patternIndex])[i][j];
            curBlock[i][j].store(fer);//(*allBlocks[patternIndex])[i][j]);
            if(fer == 1 && j < indL) indL = j;
            if(fer  == 1 && j > indR) indR = j;
        }
    }
printw("indL: %i\nindR: %i\n",indL,indR);
refresh();
this_thread::sleep_for(chrono::seconds(3));
    // for(int k=0; k<10; ++k) curBlock[k].store(init[k]);
}

void drop(char grid[20][10]){
    while(run.load()){
        bool backout = false;
        for(int i=0; i<20; ++i){
            int j=0;
            unique_lock<mutex> lock(grid_mutex);
            for(; j<4; ++j){
                for(int k=0; k<10; ++k){
                    if(i+j <= stp ){
                        if(curBlock[j][k].load()>0) grid[i+j][k] = 'X'; 
                        else grid[i+j][k] = ' '; 
                    }else{
                        backout = true;
                        break;
                    }
                }
                if(backout) break;
            }
            lock.unlock();
            this_thread::sleep_for(chrono::milliseconds(800));
            if(backout) break;
            if(i!=19) resetGrid(grid[i]);
        }
        run.store(false);
        this_thread::sleep_for(chrono::milliseconds(900));
    }
}

void resetGrid(char grid[]){
    for(int j=0; j<10; ++j){
        grid[j] = ' ';
    }
}

void printGrid(char grid[20][10]){
    clear();
    string quickGrid = "";
    for(int i=0; i<20; ++i){
        quickGrid += '|';
        for(int j=0; j<10; ++j) quickGrid += grid[i][j]; //.append(to_string(grid[i][j]));
        quickGrid += "|\n";   //.append("\n");
    }
    quickGrid += "============";
    printw("%s",quickGrid.c_str());
    //printw("%s",quickGrid);
    refresh();
}


void mov(char grid[20][10]){
    while(run.load()){
        char input = getch();
        if(input == 'a' && indL > 0) shiftLeft();
        else if(input == 'd' && indR < 9) shiftRight();
        printGrid(grid);
    }
}

void shiftLeft(){
    for(int i=0; i<4; ++i){
        for(int j=0; j<9; ++j){
            curBlock[i][j].store(curBlock[i][j+1].load()); 
        }
        curBlock[i][9].store(0);
    }
    --indL;
    --indR;
}

void shiftRight(){
    for(int i=0; i<4; ++i){
        for(int j=9; j>0; --j){
            curBlock[i][j].store(curBlock[i][j-1].load()); 
        }
        curBlock[i][0].store(0);
    }
    ++indL;
    ++indR;
}

